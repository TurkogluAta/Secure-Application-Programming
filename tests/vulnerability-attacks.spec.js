const { test, expect } = require('@playwright/test');

test.describe('SQL Injection Protection Tests', () => {

  // ==========================================
  // LOGIN SQL INJECTION PROTECTION TESTS
  // ==========================================

  test('Login - SQL injection attempt is blocked', async ({ page }) => {
    await page.goto('/login.html');

    // Attempt SQL injection
    await page.fill('input[name="username"]', "' OR 1=1--");
    await page.fill('input[name="password"]', 'anything');
    await page.click('button[type="submit"]');

    // Wait for response
    await page.waitForTimeout(2000);

    // SECURE: Should show error message instead of bypassing login
    const bodyText = await page.textContent('body');
    expect(bodyText).toContain('Invalid credentials');

    // Should still be on login page or show error
    const currentUrl = page.url();
    expect(currentUrl).toContain('login');
  });

  // ==========================================
  // REGISTER SQL INJECTION PROTECTION TESTS
  // ==========================================

  test('Register - SQL injection is prevented, malicious username stored safely', async ({ page, request }) => {
    const timestamp = Date.now();

    // Register with SQL injection payload through UI
    await page.goto('/register.html');

    // Payload: Create two users at once - include email for both users
    const maliciousUsername = `user${timestamp}', 'user${timestamp}@test.com', 'pass1'), ('hacked${timestamp}', 'hacked${timestamp}@test.com', 'pass2');--`;

    await page.fill('input[name="username"]', maliciousUsername);
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'testpass123');
    await page.fill('input[name="confirmPassword"]', 'testpass123');
    await page.click('button[type="submit"]');

    // Wait for registration to complete
    await page.waitForTimeout(2000);

    // SECURE: Try to login with the second (injected) user - should fail
    await page.goto('/login.html');
    await page.fill('input[name="username"]', `hacked${timestamp}`);
    await page.fill('input[name="password"]', 'pass2');
    await page.click('button[type="submit"]');

    // Wait for response
    await page.waitForTimeout(2000);

    // SECURE: Should NOT be able to login as injected user
    const currentUrl = page.url();
    expect(currentUrl).toContain('login');

    const bodyText = await page.textContent('body');
    expect(bodyText).toContain('Invalid credentials');
  });

  // ==========================================
  // ADD PET SQL INJECTION PROTECTION TEST
  // ==========================================

  test('Add Pet - SQL injection is prevented', async ({ page }) => {
    const timestamp = Date.now();

    // First, login with valid admin credentials
    await page.goto('/login.html');
    await page.fill('input[name="username"]', 'admin');
    await page.fill('input[name="password"]', 'admin123');
    await page.click('button[type="submit"]');

    // Wait for login to complete
    await page.waitForURL('/', { timeout: 5000 });

    // Navigate to add pet page
    await page.goto('/add-pet.html');

    // Fill the add pet form with SQL injection payload
    // Payload attempts to inject a second pet record
    const maliciousName = `TestPet${timestamp}', 'Dog', 5, 'https://example.com/dog.jpg', 'First pet', 1), ('InjectedPet${timestamp}', 'Cat', 3, 'https://example.com/cat.jpg', 'Hacked pet', 1);--`;

    await page.fill('input[name="name"]', maliciousName);
    await page.selectOption('select[name="type"]', 'Dog');
    await page.fill('input[name="age"]', '5');
    await page.fill('input[name="image_url"]', 'https://example.com/image.jpg');
    await page.fill('textarea[name="description"]', 'Test description');

    // Submit the form
    await page.click('button[type="submit"]');

    // Wait for the pet to be added
    await page.waitForTimeout(2000);

    // Navigate back to home to see all pets
    await page.goto('/');

    // Wait for pets to load
    await page.waitForTimeout(2000);

    // SECURE: Only one pet should be created with the entire malicious payload as its name
    const bodyText = await page.textContent('body');

    // SECURE: The entire malicious payload should be stored as a single pet's name (literal text)
    expect(bodyText).toContain(maliciousName);
  });
});

// ==========================================
// XSS (Cross-Site Scripting) PROTECTION TESTS
// ==========================================

test.describe('XSS Protection Tests', () => {

  // ==========================================
  // DOM-BASED XSS PROTECTION TEST (CLIENT-SIDE MODE)
  // ==========================================

  test('Search - DOM-based XSS is prevented in client-side mode', async ({ page }) => {
    // Setup alert dialog handler BEFORE navigating to the page
    let alertTriggered = false;
    let alertMessage = '';

    page.on('dialog', async dialog => {
      alertTriggered = true;
      alertMessage = dialog.message();
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page
    await page.goto('/');

    // Wait for page to load
    await page.waitForTimeout(1000);

    // Ensure toggle is in default (client-side) mode
    const toggleSwitch = page.locator('#rendering-mode-switch');
    const isChecked = await toggleSwitch.isChecked();

    // If it's in server-side mode, switch back to client-side
    if (isChecked) {
      await toggleSwitch.click();
      await page.waitForTimeout(500);
    }

    // XSS payload using alert to prove code execution
    const xssPayload = `<img src=x onerror="alert('XSS')">`;

    // Fill search input with XSS payload
    await page.fill('#search-input', xssPayload);

    // Submit the search form
    await page.click('button[type="submit"]');

    // Wait a bit to see if alert triggers
    await page.waitForTimeout(2000);

    // SECURE: Alert should NOT be triggered (XSS prevented)
    expect(alertTriggered).toBe(false);

    // SECURE: The escaped HTML should be visible as plain text (not executed)
    const bodyText = await page.textContent('body');
    // The payload should be visible as plain text (browser renders escaped HTML as text)
    expect(bodyText).toContain(`<img src=x onerror="alert('XSS')">`);
  });

  // ==========================================
  // REFLECTED XSS PROTECTION TEST (SERVER-SIDE MODE)
  // ==========================================

  test('Search - Reflected XSS is prevented in server-side mode', async ({ page }) => {
    // Setup alert dialog handler BEFORE navigating to the page
    let alertTriggered = false;
    let alertMessage = '';

    page.on('dialog', async dialog => {
      alertTriggered = true;
      alertMessage = dialog.message();
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page
    await page.goto('/');

    // Wait for page to load
    await page.waitForTimeout(1000);

    // Switch to server-side (traditional HTML) mode
    // Check current mode first
    const currentModeText = await page.locator('#current-mode').textContent();

    // If not in server-side mode, click the visible slider to switch
    if (currentModeText === 'Client-Side') {
      await page.locator('label.switch').click();
      await page.waitForTimeout(500);
    }

    // Verify we're in server-side mode
    const currentMode = await page.locator('#current-mode').textContent();
    expect(currentMode).toBe('Server-Side');

    // XSS payload using <script> tag for reflected XSS
    const xssPayload = '<script>alert("XSS Attack")</script>';

    // Fill search input with XSS payload
    await page.fill('#search-input', xssPayload);

    // Submit the search form - this will redirect to server-rendered page
    await page.click('button[type="submit"]');

    // Wait for server-side page to load
    await page.waitForTimeout(2000);

    // SECURE: Alert should NOT be triggered (reflected XSS prevented)
    expect(alertTriggered).toBe(false);

    // SECURE: The escaped script tag should be visible as plain text
    const bodyText = await page.textContent('body');
    expect(bodyText).toContain('<script>alert("XSS Attack")</script>');
  });

  // ==========================================
  // STORED XSS PROTECTION TEST (PET NAME)
  // ==========================================

  test('Add Pet - Stored XSS is prevented in pet name', async ({ page }) => {
    let alertTriggered = false;

    // First, login with admin credentials to access add pet functionality
    await page.goto('/login.html');
    await page.fill('input[name="username"]', 'admin');
    await page.fill('input[name="password"]', 'admin123');
    await page.click('button[type="submit"]');

    // Wait for login to complete
    await page.waitForURL('/', { timeout: 5000 });

    // Navigate to add pet page
    await page.goto('/add-pet.html');

    // XSS payload in pet name - attempt to execute when anyone views the pet list
    // Using String.fromCharCode to avoid SQL syntax error (SQL uses single quotes for strings)
    // fromCharCode(88,83,83) = "XSS"
    const xssPayload = `<img src=x onerror="alert(String.fromCharCode(88,83,83))">`;

    // Fill the add pet form with XSS payload in name
    await page.fill('input[name="name"]', xssPayload);
    await page.selectOption('select[name="type"]', 'Dog');
    await page.fill('input[name="age"]', '3');
    await page.fill('input[name="image_url"]', 'https://example.com/dog.jpg');
    await page.fill('textarea[name="description"]', 'A friendly dog');

    // Submit the form
    await page.click('button[type="submit"]');

    // Wait for the pet to be added
    await page.waitForTimeout(2000);

    // NOW setup alert dialog handler - only care about alerts after submitting the XSS payload
    page.on('dialog', async dialog => {
      alertTriggered = true;
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page where pet will be displayed
    await page.goto('/');

    // Wait for pets to load
    await page.waitForTimeout(2000);

    // SECURE: Alert should NOT be triggered (stored XSS prevented)
    expect(alertTriggered).toBe(false);

    // SECURE: The escaped payload should be visible as plain text
    const bodyText = await page.textContent('body');
    expect(bodyText).toContain(`<img src=x onerror="alert(String.fromCharCode(88,83,83))">`);
  });

});

// ==========================================
// SENSITIVE DATA EXPOSURE PROTECTION TESTS
// ==========================================

test.describe('Sensitive Data Exposure Protection Tests', () => {

  // ==========================================
  // HTTP HEADERS PROTECTION TEST
  // ==========================================

  test('HTTP Headers - Sensitive server information is NOT exposed', async ({ page }) => {
    // Navigate to any page
    const response = await page.goto('/');

    // Get all response headers
    const headers = response.headers();

    // SECURE: Verify sensitive headers are NOT exposed
    expect(headers['x-powered-by']).toBeUndefined();
    expect(headers['server']).toBeUndefined();
    expect(headers['x-app-version']).toBeUndefined();
    expect(headers['x-database']).toBeUndefined();
    expect(headers['x-environment']).toBeUndefined();
    expect(headers['x-server-root']).toBeUndefined();
  });

  // ==========================================
  // ADMIN PANEL SERVER-SIDE ACCESS CONTROL TEST
  // ==========================================

  test('Access Control - Admin API requires authentication', async ({ request }) => {
    // SECURE: Direct API access should be blocked without authentication
    // Unauthorized requests should receive 401
    const apiResponse = await request.get('http://localhost:3000/api/users');

    // SECURE: Should return 401 Unauthorized
    expect(apiResponse.status()).toBe(401);

    const data = await apiResponse.json();

    // SECURE: Should return error message, not user data
    expect(data.message).toBeDefined();
    expect(data.message).toContain('Authentication required');
    expect(data.users).toBeUndefined();
  });
});