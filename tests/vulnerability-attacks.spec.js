const { test, expect } = require('@playwright/test');

test.describe('SQL Injection Vulnerability Tests', () => {

  // ==========================================
  // LOGIN SQL INJECTION TESTS
  // ==========================================

  test('Login - SQL injection bypass with OR 1=1', async ({ page }) => {
    await page.goto('/login.html');

    // Attempt SQL injection
    await page.fill('input[name="username"]', "' OR 1=1--");
    await page.fill('input[name="password"]', 'anything');
    await page.click('button[type="submit"]');

    // Should successfully bypass login
    await page.waitForURL('/', { timeout: 5000 });

    // Verify we're logged in
    const welcomeText = await page.textContent('body');
    expect(welcomeText).toContain('Pets');
  });

  // ==========================================
  // REGISTER SQL INJECTION TESTS
  // ==========================================

  test('Register - SQL injection creates two users', async ({ page, request }) => {
    const timestamp = Date.now();

    // Register with SQL injection payload through UI
    await page.goto('/register.html');

    // Payload: Create two users at once - include email for both users
    const maliciousUsername = `user${timestamp}', 'user${timestamp}@test.com', 'pass1'), ('hacked${timestamp}', 'hacked${timestamp}@test.com', 'pass2');--`;

    await page.fill('input[name="username"]', maliciousUsername);
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'ignored');
    await page.fill('input[name="confirmPassword"]', 'ignored');
    await page.click('button[type="submit"]');

    // Wait for registration to complete
    await page.waitForTimeout(2000);

    // Now try to login with the second (injected) user through UI
    await page.goto('/login.html');
    await page.fill('input[name="username"]', `hacked${timestamp}`);
    await page.fill('input[name="password"]', 'pass2');
    await page.click('button[type="submit"]');

    // If we can login, SQL injection worked
    await page.waitForURL('/', { timeout: 5000 });

    // Verify we're logged in
    const welcomeText = await page.textContent('body');
    expect(welcomeText).toContain('Pets');
  });

  // ==========================================
  // ADD PET SQL INJECTION TEST
  // ==========================================

  test('Add Pet - SQL injection creates two pets', async ({ page }) => {
    const timestamp = Date.now();

    // First, login to access the add pet functionality
    await page.goto('/login.html');
    await page.fill('input[name="username"]', "' OR 1=1--");
    await page.fill('input[name="password"]', 'anything');
    await page.click('button[type="submit"]');

    // Wait for login to complete
    await page.waitForURL('/', { timeout: 5000 });

    // Navigate to add pet page
    await page.goto('/add-pet.html');

    // Fill the add pet form with SQL injection payload
    // Payload attempts to inject a second pet record by completing the first INSERT and adding a second one
    const maliciousName = `TestPet${timestamp}', 'Dog', 5, 'https://example.com/dog.jpg', 'First pet', 1), ('InjectedPet${timestamp}', 'Cat', 3, 'https://example.com/cat.jpg', 'Hacked pet', 1);--`;

    await page.fill('input[name="name"]', maliciousName);
    await page.selectOption('select[name="type"]', 'Other');
    await page.fill('input[name="age"]', '0');
    await page.fill('input[name="image_url"]', 'https://example.com/image.jpg');
    await page.fill('textarea[name="description"]', 'Test description');

    // Submit the form
    await page.click('button[type="submit"]');

    // Wait for the pets to be added
    await page.waitForTimeout(2000);

    // Navigate back to home to see all pets
    await page.goto('/');

    // Wait for pets to load
    await page.waitForTimeout(2000);

    // Verify both pets were created
    const bodyText = await page.textContent('body');
    expect(bodyText).toContain(`TestPet${timestamp}`);
    expect(bodyText).toContain(`InjectedPet${timestamp}`);
  });
});

// ==========================================
// XSS (Cross-Site Scripting) VULNERABILITY TESTS
// ==========================================

test.describe('XSS Vulnerability Tests', () => {

  // ==========================================
  // DOM-BASED XSS TEST (CLIENT-SIDE MODE)
  // ==========================================

  test('Search - DOM-based XSS in client-side mode', async ({ page }) => {
    // Setup alert dialog handler BEFORE navigating to the page
    let alertTriggered = false;
    let alertMessage = '';

    page.on('dialog', async dialog => {
      alertTriggered = true;
      alertMessage = dialog.message();
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page
    await page.goto('/');

    // Wait for page to load
    await page.waitForTimeout(1000);

    // Ensure toggle is in default (client-side) mode
    const toggleSwitch = page.locator('#rendering-mode-switch');
    const isChecked = await toggleSwitch.isChecked();

    // If it's in server-side mode, switch back to client-side
    if (isChecked) {
      await toggleSwitch.click();
      await page.waitForTimeout(500);
    }

    // XSS payload using alert to prove code execution
    const xssPayload = `<img src=x onerror="alert('XSS')">`;

    // Fill search input with XSS payload
    await page.fill('#search-input', xssPayload);

    // Submit the search form - this will trigger the XSS
    await page.click('button[type="submit"]');

    // Wait a bit for the alert to trigger
    await page.waitForTimeout(2000);

    // Verify alert was triggered (XSS executed)
    expect(alertTriggered).toBe(true);
    expect(alertMessage).toBe('XSS');
  });

  // ==========================================
  // REFLECTED XSS TEST (SERVER-SIDE MODE)
  // ==========================================

  test('Search - Reflected XSS in server-side mode', async ({ page }) => {
    // Setup alert dialog handler BEFORE navigating to the page
    let alertTriggered = false;
    let alertMessage = '';

    page.on('dialog', async dialog => {
      alertTriggered = true;
      alertMessage = dialog.message();
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page
    await page.goto('/');

    // Wait for page to load
    await page.waitForTimeout(1000);

    // Switch to server-side (traditional HTML) mode
    // Check current mode first
    const currentModeText = await page.locator('#current-mode').textContent();

    // If not in server-side mode, click the visible slider to switch
    if (currentModeText === 'Client-Side') {
      await page.locator('label.switch').click();
      await page.waitForTimeout(500);
    }

    // Verify we're in server-side mode
    const currentMode = await page.locator('#current-mode').textContent();
    expect(currentMode).toBe('Server-Side');

    // XSS payload using <script> tag for reflected XSS
    const xssPayload = '<script>alert("XSS Attack")</script>';

    // Fill search input with XSS payload
    await page.fill('#search-input', xssPayload);

    // Submit the search form - this will redirect to server-rendered page
    await page.click('button[type="submit"]');

    // Wait for server-side page to load and XSS to execute
    await page.waitForTimeout(2000);

    // Verify alert was triggered (reflected XSS executed)
    expect(alertTriggered).toBe(true);
    expect(alertMessage).toBe('XSS Attack');
  });

  // ==========================================
  // STORED XSS TEST (PET NAME)
  // ==========================================

  test('Add Pet - Stored XSS in pet name', async ({ page }) => {
    let alertTriggered = false;
    let alertMessage = '';

    // First, login with admin credentials to access add pet functionality
    await page.goto('/login.html');
    await page.fill('input[name="username"]', 'admin');
    await page.fill('input[name="password"]', 'admin123');
    await page.click('button[type="submit"]');

    // Wait for login to complete
    await page.waitForURL('/', { timeout: 5000 });

    // Navigate to add pet page
    await page.goto('/add-pet.html');

    // XSS payload in pet name - will execute when anyone views the pet list
    // Using String.fromCharCode to avoid SQL syntax error (SQL uses single quotes for strings)
    // fromCharCode(88,83,83) = "XSS"
    const xssPayload = `<img src=x onerror="alert(String.fromCharCode(88,83,83))">`;

    // Fill the add pet form with XSS payload in name
    await page.fill('input[name="name"]', xssPayload);
    await page.selectOption('select[name="type"]', 'Dog');
    await page.fill('input[name="age"]', '3');
    await page.fill('input[name="image_url"]', 'https://example.com/dog.jpg');
    await page.fill('textarea[name="description"]', 'A friendly dog');

    // Submit the form
    await page.click('button[type="submit"]');

    // Wait for the pet to be added
    await page.waitForTimeout(2000);

    // NOW setup alert dialog handler - only care about alerts after submitting the XSS payload
    page.on('dialog', async dialog => {
      alertTriggered = true;
      alertMessage = dialog.message();
      await dialog.accept(); // Close the alert
    });

    // Navigate to home page where pet will be displayed
    await page.goto('/');

    // Wait for pets to load and XSS to execute
    await page.waitForTimeout(2000);

    // Verify alert was triggered (stored XSS executed when page loaded)
    expect(alertTriggered).toBe(true);
    expect(alertMessage).toBe('XSS');
  });

});

// ==========================================
// SENSITIVE DATA EXPOSURE VULNERABILITY TESTS
// ==========================================

test.describe('Sensitive Data Exposure Tests', () => {

  // ==========================================
  // HTTP HEADERS EXPOSURE TEST
  // ==========================================

  test('HTTP Headers - Sensitive server information exposed', async ({ page }) => {
    // Navigate to any page
    const response = await page.goto('/');

    // Get all response headers
    const headers = response.headers();

    // Verify sensitive headers are exposed
    expect(headers['x-powered-by']).toBeDefined();
    expect(headers['server']).toBeDefined();
    expect(headers['x-app-version']).toBeDefined();
    expect(headers['x-database']).toBeDefined();
    expect(headers['x-environment']).toBeDefined();
    expect(headers['x-server-root']).toBeDefined();

  });

  // ==========================================
  // ADMIN PANEL CLIENT-SIDE ONLY ACCESS CONTROL
  // ==========================================

  test('Access Control - Admin API has no server-side authentication', async ({ request }) => {
    // VULNERABILITY: Direct API access bypasses client-side checks
    // Anyone can curl/fetch this endpoint directly without authentication
    const apiResponse = await request.get('http://localhost:3000/api/users');
    expect(apiResponse.status()).toBe(200);

    const data = await apiResponse.json();

    // VULNERABILITY: API endpoint has no server-side authentication
    expect(data.success).toBe(true);
    expect(data.users).toBeDefined();

    // All sensitive data is exposed
    data.users.forEach(user => {
      expect(user.username).toBeDefined();
      expect(user.email).toBeDefined();
      expect(user.password).toBeDefined(); // Plaintext!
      expect(user.is_admin).toBeDefined();
    });
  });

});